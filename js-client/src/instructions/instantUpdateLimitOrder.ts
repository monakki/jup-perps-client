/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit'
import { PERPETUALS_PROGRAM_ADDRESS } from '../programs'
import { getAccountMetaFactory, type ResolvedAccount } from '../shared'

export const INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR = new Uint8Array([
  136, 245, 229, 58, 121, 141, 12, 207,
])

export function getInstantUpdateLimitOrderDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR
  )
}

export type InstantUpdateLimitOrderInstruction<
  TProgram extends string = typeof PERPETUALS_PROGRAM_ADDRESS,
  TAccountKeeper extends string | AccountMeta<string> = string,
  TAccountApiKeeper extends string | AccountMeta<string> = string,
  TAccountOwner extends string | AccountMeta<string> = string,
  TAccountPerpetuals extends string | AccountMeta<string> = string,
  TAccountPool extends string | AccountMeta<string> = string,
  TAccountPosition extends string | AccountMeta<string> = string,
  TAccountPositionRequest extends string | AccountMeta<string> = string,
  TAccountCustody extends string | AccountMeta<string> = string,
  TAccountCustodyDovesPriceAccount extends
    | string
    | AccountMeta<string> = string,
  TAccountCustodyPythnetPriceAccount extends
    | string
    | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountKeeper extends string
        ? ReadonlySignerAccount<TAccountKeeper> &
            AccountSignerMeta<TAccountKeeper>
        : TAccountKeeper,
      TAccountApiKeeper extends string
        ? ReadonlySignerAccount<TAccountApiKeeper> &
            AccountSignerMeta<TAccountApiKeeper>
        : TAccountApiKeeper,
      TAccountOwner extends string
        ? ReadonlySignerAccount<TAccountOwner> &
            AccountSignerMeta<TAccountOwner>
        : TAccountOwner,
      TAccountPerpetuals extends string
        ? ReadonlyAccount<TAccountPerpetuals>
        : TAccountPerpetuals,
      TAccountPool extends string
        ? ReadonlyAccount<TAccountPool>
        : TAccountPool,
      TAccountPosition extends string
        ? ReadonlyAccount<TAccountPosition>
        : TAccountPosition,
      TAccountPositionRequest extends string
        ? WritableAccount<TAccountPositionRequest>
        : TAccountPositionRequest,
      TAccountCustody extends string
        ? ReadonlyAccount<TAccountCustody>
        : TAccountCustody,
      TAccountCustodyDovesPriceAccount extends string
        ? ReadonlyAccount<TAccountCustodyDovesPriceAccount>
        : TAccountCustodyDovesPriceAccount,
      TAccountCustodyPythnetPriceAccount extends string
        ? ReadonlyAccount<TAccountCustodyPythnetPriceAccount>
        : TAccountCustodyPythnetPriceAccount,
      ...TRemainingAccounts,
    ]
  >

export type InstantUpdateLimitOrderInstructionData = {
  discriminator: ReadonlyUint8Array
  sizeUsdDelta: bigint
  triggerPrice: bigint
  requestTime: bigint
}

export type InstantUpdateLimitOrderInstructionDataArgs = {
  sizeUsdDelta: number | bigint
  triggerPrice: number | bigint
  requestTime: number | bigint
}

export function getInstantUpdateLimitOrderInstructionDataEncoder(): FixedSizeEncoder<InstantUpdateLimitOrderInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['sizeUsdDelta', getU64Encoder()],
      ['triggerPrice', getU64Encoder()],
      ['requestTime', getI64Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: INSTANT_UPDATE_LIMIT_ORDER_DISCRIMINATOR,
    })
  )
}

export function getInstantUpdateLimitOrderInstructionDataDecoder(): FixedSizeDecoder<InstantUpdateLimitOrderInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['sizeUsdDelta', getU64Decoder()],
    ['triggerPrice', getU64Decoder()],
    ['requestTime', getI64Decoder()],
  ])
}

export function getInstantUpdateLimitOrderInstructionDataCodec(): FixedSizeCodec<
  InstantUpdateLimitOrderInstructionDataArgs,
  InstantUpdateLimitOrderInstructionData
> {
  return combineCodec(
    getInstantUpdateLimitOrderInstructionDataEncoder(),
    getInstantUpdateLimitOrderInstructionDataDecoder()
  )
}

export type InstantUpdateLimitOrderInput<
  TAccountKeeper extends string = string,
  TAccountApiKeeper extends string = string,
  TAccountOwner extends string = string,
  TAccountPerpetuals extends string = string,
  TAccountPool extends string = string,
  TAccountPosition extends string = string,
  TAccountPositionRequest extends string = string,
  TAccountCustody extends string = string,
  TAccountCustodyDovesPriceAccount extends string = string,
  TAccountCustodyPythnetPriceAccount extends string = string,
> = {
  keeper: TransactionSigner<TAccountKeeper>
  apiKeeper: TransactionSigner<TAccountApiKeeper>
  owner: TransactionSigner<TAccountOwner>
  perpetuals: Address<TAccountPerpetuals>
  pool: Address<TAccountPool>
  position: Address<TAccountPosition>
  positionRequest: Address<TAccountPositionRequest>
  custody: Address<TAccountCustody>
  custodyDovesPriceAccount: Address<TAccountCustodyDovesPriceAccount>
  custodyPythnetPriceAccount: Address<TAccountCustodyPythnetPriceAccount>
  sizeUsdDelta: InstantUpdateLimitOrderInstructionDataArgs['sizeUsdDelta']
  triggerPrice: InstantUpdateLimitOrderInstructionDataArgs['triggerPrice']
  requestTime: InstantUpdateLimitOrderInstructionDataArgs['requestTime']
}

export function getInstantUpdateLimitOrderInstruction<
  TAccountKeeper extends string,
  TAccountApiKeeper extends string,
  TAccountOwner extends string,
  TAccountPerpetuals extends string,
  TAccountPool extends string,
  TAccountPosition extends string,
  TAccountPositionRequest extends string,
  TAccountCustody extends string,
  TAccountCustodyDovesPriceAccount extends string,
  TAccountCustodyPythnetPriceAccount extends string,
  TProgramAddress extends Address = typeof PERPETUALS_PROGRAM_ADDRESS,
>(
  input: InstantUpdateLimitOrderInput<
    TAccountKeeper,
    TAccountApiKeeper,
    TAccountOwner,
    TAccountPerpetuals,
    TAccountPool,
    TAccountPosition,
    TAccountPositionRequest,
    TAccountCustody,
    TAccountCustodyDovesPriceAccount,
    TAccountCustodyPythnetPriceAccount
  >,
  config?: { programAddress?: TProgramAddress }
): InstantUpdateLimitOrderInstruction<
  TProgramAddress,
  TAccountKeeper,
  TAccountApiKeeper,
  TAccountOwner,
  TAccountPerpetuals,
  TAccountPool,
  TAccountPosition,
  TAccountPositionRequest,
  TAccountCustody,
  TAccountCustodyDovesPriceAccount,
  TAccountCustodyPythnetPriceAccount
> {
  // Program address.
  const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS

  // Original accounts.
  const originalAccounts = {
    keeper: { value: input.keeper ?? null, isWritable: false },
    apiKeeper: { value: input.apiKeeper ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false },
    perpetuals: { value: input.perpetuals ?? null, isWritable: false },
    pool: { value: input.pool ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: false },
    positionRequest: { value: input.positionRequest ?? null, isWritable: true },
    custody: { value: input.custody ?? null, isWritable: false },
    custodyDovesPriceAccount: {
      value: input.custodyDovesPriceAccount ?? null,
      isWritable: false,
    },
    custodyPythnetPriceAccount: {
      value: input.custodyPythnetPriceAccount ?? null,
      isWritable: false,
    },
  }
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >

  // Original args.
  const args = { ...input }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId')
  const instruction = {
    accounts: [
      getAccountMeta(accounts.keeper),
      getAccountMeta(accounts.apiKeeper),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.perpetuals),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionRequest),
      getAccountMeta(accounts.custody),
      getAccountMeta(accounts.custodyDovesPriceAccount),
      getAccountMeta(accounts.custodyPythnetPriceAccount),
    ],
    programAddress,
    data: getInstantUpdateLimitOrderInstructionDataEncoder().encode(
      args as InstantUpdateLimitOrderInstructionDataArgs
    ),
  } as InstantUpdateLimitOrderInstruction<
    TProgramAddress,
    TAccountKeeper,
    TAccountApiKeeper,
    TAccountOwner,
    TAccountPerpetuals,
    TAccountPool,
    TAccountPosition,
    TAccountPositionRequest,
    TAccountCustody,
    TAccountCustodyDovesPriceAccount,
    TAccountCustodyPythnetPriceAccount
  >

  return instruction
}

export type ParsedInstantUpdateLimitOrderInstruction<
  TProgram extends string = typeof PERPETUALS_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>
  accounts: {
    keeper: TAccountMetas[0]
    apiKeeper: TAccountMetas[1]
    owner: TAccountMetas[2]
    perpetuals: TAccountMetas[3]
    pool: TAccountMetas[4]
    position: TAccountMetas[5]
    positionRequest: TAccountMetas[6]
    custody: TAccountMetas[7]
    custodyDovesPriceAccount: TAccountMetas[8]
    custodyPythnetPriceAccount: TAccountMetas[9]
  }
  data: InstantUpdateLimitOrderInstructionData
}

export function parseInstantUpdateLimitOrderInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedInstantUpdateLimitOrderInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error('Not enough accounts')
  }
  let accountIndex = 0
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!
    accountIndex += 1
    return accountMeta
  }
  return {
    programAddress: instruction.programAddress,
    accounts: {
      keeper: getNextAccount(),
      apiKeeper: getNextAccount(),
      owner: getNextAccount(),
      perpetuals: getNextAccount(),
      pool: getNextAccount(),
      position: getNextAccount(),
      positionRequest: getNextAccount(),
      custody: getNextAccount(),
      custodyDovesPriceAccount: getNextAccount(),
      custodyPythnetPriceAccount: getNextAccount(),
    },
    data: getInstantUpdateLimitOrderInstructionDataDecoder().decode(
      instruction.data
    ),
  }
}
