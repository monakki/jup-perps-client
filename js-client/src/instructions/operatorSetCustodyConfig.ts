/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getF32Decoder,
  getF32Encoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit'
import { PERPETUALS_PROGRAM_ADDRESS } from '../programs'
import { getAccountMetaFactory, type ResolvedAccount } from '../shared'
import {
  getJumpRateStateDecoder,
  getJumpRateStateEncoder,
  getPricingParamsDecoder,
  getPricingParamsEncoder,
  type JumpRateState,
  type JumpRateStateArgs,
  type PricingParams,
  type PricingParamsArgs,
} from '../types'

export const OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR = new Uint8Array([
  166, 137, 92, 204, 145, 224, 24, 218,
])

export function getOperatorSetCustodyConfigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR
  )
}

export type OperatorSetCustodyConfigInstruction<
  TProgram extends string = typeof PERPETUALS_PROGRAM_ADDRESS,
  TAccountOperator extends string | AccountMeta<string> = string,
  TAccountCustody extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountOperator extends string
        ? ReadonlySignerAccount<TAccountOperator> &
            AccountSignerMeta<TAccountOperator>
        : TAccountOperator,
      TAccountCustody extends string
        ? WritableAccount<TAccountCustody>
        : TAccountCustody,
      ...TRemainingAccounts,
    ]
  >

export type OperatorSetCustodyConfigInstructionData = {
  discriminator: ReadonlyUint8Array
  pricing: PricingParams
  hourlyFundingDbps: bigint
  targetRatioBps: bigint
  increasePositionBps: bigint
  decreasePositionBps: bigint
  maxPositionSizeUsd: bigint
  jumpRate: JumpRateState
  priceImpactFeeFactor: bigint
  priceImpactExponent: number
  deltaImbalanceThresholdDecimal: bigint
  maxFeeBps: bigint
}

export type OperatorSetCustodyConfigInstructionDataArgs = {
  pricing: PricingParamsArgs
  hourlyFundingDbps: number | bigint
  targetRatioBps: number | bigint
  increasePositionBps: number | bigint
  decreasePositionBps: number | bigint
  maxPositionSizeUsd: number | bigint
  jumpRate: JumpRateStateArgs
  priceImpactFeeFactor: number | bigint
  priceImpactExponent: number
  deltaImbalanceThresholdDecimal: number | bigint
  maxFeeBps: number | bigint
}

export function getOperatorSetCustodyConfigInstructionDataEncoder(): FixedSizeEncoder<OperatorSetCustodyConfigInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['pricing', getPricingParamsEncoder()],
      ['hourlyFundingDbps', getU64Encoder()],
      ['targetRatioBps', getU64Encoder()],
      ['increasePositionBps', getU64Encoder()],
      ['decreasePositionBps', getU64Encoder()],
      ['maxPositionSizeUsd', getU64Encoder()],
      ['jumpRate', getJumpRateStateEncoder()],
      ['priceImpactFeeFactor', getU64Encoder()],
      ['priceImpactExponent', getF32Encoder()],
      ['deltaImbalanceThresholdDecimal', getU64Encoder()],
      ['maxFeeBps', getU64Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: OPERATOR_SET_CUSTODY_CONFIG_DISCRIMINATOR,
    })
  )
}

export function getOperatorSetCustodyConfigInstructionDataDecoder(): FixedSizeDecoder<OperatorSetCustodyConfigInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['pricing', getPricingParamsDecoder()],
    ['hourlyFundingDbps', getU64Decoder()],
    ['targetRatioBps', getU64Decoder()],
    ['increasePositionBps', getU64Decoder()],
    ['decreasePositionBps', getU64Decoder()],
    ['maxPositionSizeUsd', getU64Decoder()],
    ['jumpRate', getJumpRateStateDecoder()],
    ['priceImpactFeeFactor', getU64Decoder()],
    ['priceImpactExponent', getF32Decoder()],
    ['deltaImbalanceThresholdDecimal', getU64Decoder()],
    ['maxFeeBps', getU64Decoder()],
  ])
}

export function getOperatorSetCustodyConfigInstructionDataCodec(): FixedSizeCodec<
  OperatorSetCustodyConfigInstructionDataArgs,
  OperatorSetCustodyConfigInstructionData
> {
  return combineCodec(
    getOperatorSetCustodyConfigInstructionDataEncoder(),
    getOperatorSetCustodyConfigInstructionDataDecoder()
  )
}

export type OperatorSetCustodyConfigInput<
  TAccountOperator extends string = string,
  TAccountCustody extends string = string,
> = {
  operator: TransactionSigner<TAccountOperator>
  custody: Address<TAccountCustody>
  pricing: OperatorSetCustodyConfigInstructionDataArgs['pricing']
  hourlyFundingDbps: OperatorSetCustodyConfigInstructionDataArgs['hourlyFundingDbps']
  targetRatioBps: OperatorSetCustodyConfigInstructionDataArgs['targetRatioBps']
  increasePositionBps: OperatorSetCustodyConfigInstructionDataArgs['increasePositionBps']
  decreasePositionBps: OperatorSetCustodyConfigInstructionDataArgs['decreasePositionBps']
  maxPositionSizeUsd: OperatorSetCustodyConfigInstructionDataArgs['maxPositionSizeUsd']
  jumpRate: OperatorSetCustodyConfigInstructionDataArgs['jumpRate']
  priceImpactFeeFactor: OperatorSetCustodyConfigInstructionDataArgs['priceImpactFeeFactor']
  priceImpactExponent: OperatorSetCustodyConfigInstructionDataArgs['priceImpactExponent']
  deltaImbalanceThresholdDecimal: OperatorSetCustodyConfigInstructionDataArgs['deltaImbalanceThresholdDecimal']
  maxFeeBps: OperatorSetCustodyConfigInstructionDataArgs['maxFeeBps']
}

export function getOperatorSetCustodyConfigInstruction<
  TAccountOperator extends string,
  TAccountCustody extends string,
  TProgramAddress extends Address = typeof PERPETUALS_PROGRAM_ADDRESS,
>(
  input: OperatorSetCustodyConfigInput<TAccountOperator, TAccountCustody>,
  config?: { programAddress?: TProgramAddress }
): OperatorSetCustodyConfigInstruction<
  TProgramAddress,
  TAccountOperator,
  TAccountCustody
> {
  // Program address.
  const programAddress = config?.programAddress ?? PERPETUALS_PROGRAM_ADDRESS

  // Original accounts.
  const originalAccounts = {
    operator: { value: input.operator ?? null, isWritable: false },
    custody: { value: input.custody ?? null, isWritable: true },
  }
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >

  // Original args.
  const args = { ...input }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId')
  const instruction = {
    accounts: [
      getAccountMeta(accounts.operator),
      getAccountMeta(accounts.custody),
    ],
    programAddress,
    data: getOperatorSetCustodyConfigInstructionDataEncoder().encode(
      args as OperatorSetCustodyConfigInstructionDataArgs
    ),
  } as OperatorSetCustodyConfigInstruction<
    TProgramAddress,
    TAccountOperator,
    TAccountCustody
  >

  return instruction
}

export type ParsedOperatorSetCustodyConfigInstruction<
  TProgram extends string = typeof PERPETUALS_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>
  accounts: {
    operator: TAccountMetas[0]
    custody: TAccountMetas[1]
  }
  data: OperatorSetCustodyConfigInstructionData
}

export function parseOperatorSetCustodyConfigInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedOperatorSetCustodyConfigInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 2) {
    // TODO: Coded error.
    throw new Error('Not enough accounts')
  }
  let accountIndex = 0
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!
    accountIndex += 1
    return accountMeta
  }
  return {
    programAddress: instruction.programAddress,
    accounts: {
      operator: getNextAccount(),
      custody: getNextAccount(),
    },
    data: getOperatorSetCustodyConfigInstructionDataDecoder().decode(
      instruction.data
    ),
  }
}
